We chose to use a flask application because we knew we wanted to have a more dynamic webpage that allowed for ideas like randomization of the QuackLib template when the user pressed a button. We also knew we would want to use jinja to modify the stories based on user input. 

Our app.py code is fairly simple and mostly serves to redirect the user to various pages. Its primary role is to take user input from the forms and pass that input to the "done" version of that .html page. 

One thing our group spent a long time on is the most effective way to collect user input given that all of our forms were of different lengths and requested different types of words. We considered at one point having a uniform file that everyone filled out and then randomizing the output instead, but decided it didn't make a lot of sense for users to fill in more words than were needed. Because of this, we opted to use individual forms for each QuackLib. The setup for this takes the form of a .html page (ex. disney1.html) that has an output page (disney1_done.html), sort of like quote and quoted from our finance problem set. We designed the process also so that once the user clicks the submit button, the "done" template is generated with the output text and a fun picture related to the story. For the form, we used bootstrap to implement an accordian. The accordion component is used on our input forms in order to make it easier for the user to not have to scroll if there are many required inputs on a given page. 

We also wanted to  implement a feature that randomized which QuackLib the user got to fill out. We chose to create a function for this in a separate JavaScript file (random.js) because it would be used on multiple different pages and involved lengthy code. We discussed in office hours that despite the fact that python might be preferable for simplicity of the code, the random number generating aspect in JavaScript would work better. In random.js, a random number between 0-2 is generated. That number is then used to index into a list of links; this list is passed to the function. The user is then redirected to that link. This gives the user limited control over which QuackLib they play. One flaw with this method is that the user may fill out the same QuackLib more than once, but we also think it's fun that the user might get to replay the same story, but have a completely different output.

We hand-wrote three different unique MadLibs storylines that feature CS 50 DDB as the main character, and then used a combination of ChatGPT and our own human edits to modify these storylines to be of less or more difficulty to match the reading level they correspond to. From there, we used a reading level calculator (please reference the exact link shown above) that we used to confirm that the difficulty of the storyline was on-par with the reading level we associated it with. This process was done for all three storylines, with the storylines themselves remaining the same across all 5 reading level options, but the difficulty varying based on the reading level. The storylines that we created are "Duck Takes a Tour!," "Duck Disappearance!," and "Duck Goes to Disney!" that have associated input and output .html files that are shown in the "templates" folder. The .html input form files associated with "Duck Takes a Tour!" are shown in town#.html (with the # ranging from 1-5 based on level with 1 as grade 2 and below). The .html output form files associated with "Duck Takes a Tour!" are shown in town#_done.html (with the # ranging from 1-5 based on level with 1 as grade 2 and below). The .html input form files associated with "Duck Disappearance!" are shown in disappearance#.html (with the # ranging from 1-5 based on level with 1 as grade 2 and below). The .html output form files associated with "Duck Disappearance!" are shown in disappearance#_done.html (with the # ranging from 1-5 based on level with 1 as grade 2 and below). The .html input form files associated with "Duck Goes to Disney!" are shown in disney#.html (with the # ranging from 1-5 based on level with 1 as grade 2 and below). The .html output form files associated with "Duck Goes to Disney!" are shown in disney#_done.html (with the # ranging from 1-5 based on level with 1 as grade 2 and below). The styling for all of these .html files originates from our "style.css" file listed under the "static" folder. Please refer to our "DESIGN.md" file for design/asthetic comments that are more elaborate and detailed in nature. 

In order to make sure that elements like names and other inputs that need to be capitalized are indeed capitalized in the output form, we implemented a "capitalize-output" function that is shown in the "layout.html" page listed under the "templates" folder and then referenced this for each input blank using the class="capitalize-output" command in each of the .html input pages for the associated QuackLib. In addition, we also put `<u></u>` around each imported input spot on each of the .html output pages in order to make sure the inputted words are underlined like a typical MadLib (or in this case QuackLib) would be. 
 
Since our stories surround the CS50 duck, we wanted the website to look earthy, similar to the environment of a duck in a pond. This is why the background is mostly blue - the CS50 Duck thrives in the pond waters. It allows them to move more efficiently, it is where their food sources lie as well, and it's usually the safest place to be for a duck. The pastel green for the header and footer was to describe the land. Ducks use vegetation to engage in more complex projects such as birth, so we thought putting the navbar in that area would symbolize the place to get everywhere you would possibly need to get to in one place. We put white space with a duck for each grade level to make it look more appealing, as white space makes the screen more aesthetically pleasing.

If you toggle over the buttons, you will be able to see a slight angle of the button. This was just to show that the button does work when the computer may be running slow. It has an orange outline to symbolize a duck's beak. Just as a duck uses its beak to eat, users pressing on the button enables them to consume their stories as they see fit.

When the stories are processed, pictures are shown at the end of the story so the user-created story can be visualized. This helps the reader not only see words but also see their stories.

Our website used bootstrap to implement a navigation bar for ease of use. Overall, the aesthetic presented on our website is supposed to be able to bring the story templates that we have created to life by the user, and for them to embrace the CS50 duck DDB in all its glory. 



